4.4.	Generalized Python Data Processing Functions
The functions below describe common processes performed in the analysis of MRI data. We have take the approach of utilizing JSON files to minimize the command line input necessary to perform this processing. Also, each program is batched through the utilization of MySQL queries formatted using input provided by these JSON files. Although each program is batched, and single-file analyses are not the focus of these programs (however they can be performed by modifying the queries), each function only processes data if output data from each program is not detected (on either the AWS S3 bucket, MySQL database, or local s3/scratch directories) unless the overwrite flag is specified. 
NOTE: some of the functions described below do need to be modified when new projects are added. Functionality to eliminate this modification needs to be developed and implemented.
4.4.1.	kaas_dcm2nii.py
Function to convert raw dicom images exported by MRI or other acquisition technologies to NIfTI format. The function inputs are detailed in Table 12. This function will output *somewhat* random filenames in the format:
<containing folder name>_sequence name>_<series number>.nii.gz.
Each NIfTI image will contain a limited header copied from the DICOM images and the images themselse. Additional header information will be stored in JSON and txt files (with the same names as the NIfTI images) that are also output in the conversion process. 
This program utilizes the dcm2niix conversion package from MRIcro. MRIcro is a rendering and conversion software package developed at Chris Rorden’s Neuropsychology Lab at University of South Carolina and is the distributed by NeuroImaging and Resources Collaboratory (NITRC).
This function will query the selected table/database for any DICOM files in the “raw_data” directory. Output NIfTI files will be placed in a folder in the scratch directory in correspondence with the input DICOM directory. A flowchart detailing the high-level programmatic steps of this program are outlined in Figure 5.
4.4.2.	kaas_cp_raw_nii.py
This function is used to create more appropriate filenames for the NIfTI files output from DICOM conversion. The combination of this function with kaas_dcm2nii.py is depicted in Figure 6. NIfTI files from the  “raw_data” folder in the project’s scratch directory will be renamed and placed in the “processed_data” folder in the scratch directory. Spectroscopy (RDA and P-files), data files (LOG and DAT), and text files will also be copied. The command line options are specified in Table 14.
4.4.3.	kaas_flirt.py
This program implements FSL’s FLIRT algorithm to register two images, and accesses FLIRT via nipype’s interface. This function is quite lengthy and complex, but is meant to serve many purposes. Table 14 describes the command line arguments for this function. 
First, we will discuss parameters for registration that will be utilized for any registration implemented in this program. Prior to execution, a project-specific JSON file MUST exist within the ‘processing_scripts’ sub-directory in the project’s scratch directory. This JSON file must be titled <project>_flirt_input.json. This file contains a few search parameters including the keys ‘asl_regexstr’, ‘struc_regexstr’, ‘inclusionList’, and ‘exclusionList’. Both ‘asl_regexstr’ and ‘struc_regexstr’ are only required for ASL registration. The inclusion and exclusion keys are not necessary. Please perform queries using the proper python tools prior to running to ensure proper results are achieved. The remaining keys align with those detailed in the nipype interface documentation for FLIRT:
https://nipype.readthedocs.io/en/latest/api/generated/nipype.interfaces.fsl.preprocess.html.
Registration will be attempted for ALL files that are returned from the search query matching the parameters specified in the FLIRT JSON file (see Section 5.2.2).
Second, we will discuss structural registration. Structural registration is completed within struc_flirt.py. If BET is not skipped, brain extraction will be performed via the parameters specified in the project’s BET JSON file (see Section 5.2.3). Next, FLIRT will be performed. If the --use-1mm flag is utilized, the MNI 1mm template is used, otherwise the 2mm template is used (by default). This process will produce structural to standard transformation matrices (highres2standard.mat and standard2highres.mat), an image of the structural image in standard space (*_std_1mm.nii.gz or *_std_2mm.nii.gz), and an overlay image (highres2standard.png). The results from registration (other than the standard space transformed image) will be placed in *.reg, where * represents the basename of the input structural image. The output will be placed in the subject/session folder of the ‘processed_data’ sub-directory of the project’s scratch directory.
Finally, ASL registration will be discussed. ASL registration is very similar to structural registration except it will perform registration between ASL and structural AND ASL and standard space (if structural to standard registration results exist). 
FLIRT will only be performed when registration output is not found locally or on the AWS S3 bucket, unless the overwrite flag (--OVERWRITE) is specified. 
ASL and structural registration can be combined to run at the same time via a single command line input. If processing via CONDOR is selected (-s | --submit), a single job will be created for each call to kaas_flirt.py. Several sub-jobs will exist depending on the execution. In general, these sub-jobs will be BET, structural FLIRT via struc_flirt.py, and ASL FLIRT via asl_2d_flirt.py or asl_flirt.py. There is hierarchy between these jobs due to the file demands, thus all BET jobs must complete before any structural FLIRT jobs are executed, and all structural FLIRT jobs must complete before any ASL FLIRT jobs (see Figure 4). The HTCondor dagman also produces job-related files that are output in the ‘processing_logs’ sub-directory of the project’s scratch directory (see Figure 5).
OUTPUT: This program creates the registration directory *.reg by replacing the extension (.nii.gz) from the input file within the project’s scratch directory. This directory contains the transformation matrices as well as images used to confirm the quality of registration. You should check these images prior to proceeding. Additionally, a standard-space transformed image is output in the project’s scratch directory.
4.4.4.	kaas_compute_cbf.py
This program implements FSL’s oxford_asl algorithm to compute cerebral perfusion (CBF) from raw ASL difference or tag-control image sets. Because oxford_asl is not currently in nipype’s interface for FSL, a custom oxford_asl class has been created to mimick functionality of nipype’s interface. This is described in Section 3.4.2. This function is built to be very versatile and implements a JSON parameter implementation similar to other functions described previously. Therefore, command line options (Table 15) are quite minimal. 
First, we will discuss parameters for oxford_asl that will be utilized in this program. Prior to execution, a project-specific JSON file MUST exist within the ‘processing_scripts’ sub-directory in the project’s scratch directory (see Section 5.2.6). This JSON file must be titled <project>_oxford_asl_input.json. This file contains a few search parameters including the keys ‘asl_regexstr’, ‘struc_regexstr’, ‘m0_regexstr’, ‘inclusionList’, and ‘exclusionList’. Only ‘asl_regexstr’ is required. If struc_regexstr is supplied, output from fsl_anat will be queried and, if necessary, fsl_anat will be ran. If m0_regexstr is supplied, calibration will be performed. Calibration is necessary to produce quantified output, otherwise the output will  be relative. The inclusion and exclusion keys are not necessary. Please perform queries using the proper python tools prior to running to ensure proper results are achieved for each of these search characteristics. Please note that the inclusion and exclusion criteria will ONLY be applied to the ASL search. The other remaining searches will be restricted to the directory containing the ASL data (and its corresponding s3 and scratch directories). The remaining keys align with those detailed in ‘oxford_asl --more'.
Next, we will discuss BET and fsl_anat. Brain extraction will be performed using the parameters specified in <project>_bet_input.json if not skipped and if either BET output does not exists or overwrite is specified. BET output add ‘_brain’ to the basename of the structural image and places this file in the subject/session file within the ‘processed_data’ sub-directory of the project’s scratch directory. Anatomical processing will be performed using fsl_anat to perform anatomical segmentation and other various functions that are utilized in oxford_asl. Output from fsl_anat is placed in a folder *.anat where * is the basename of the structural image. This output folder is placed in the subject/session file within the ‘processed_data’ sub-directory of the project’s scratch directory.
Finally, oxford_asl is ran. Output is placed in a folder titled *.asl where * is the basename of the ASL input file. This folder is created in the subject/session file within the ‘processed_data’ sub-directory of the project’s scratch directory.
These processes can be combined to run at the same time via a single call to kaas_compute_cbf.py. If processing via CONDOR is selected (-s | --submit), a single job will be created for each call to kaas_compute_cbf.py. Several sub-jobs will exist depending on the execution. In general, these sub-jobs will be BET, fsl_anat, and oxford_asl. There is hierarchy between these jobs due to the file demands, thus all BET jobs must complete before any fsl_anat jobs are executed, and all fsl_anat jobs must complete before any oxford_asl jobs (see Figure 6). The HTCondor dagman also produces job-related files that are output in the ‘processing_logs’ sub-directory of the project’s scratch directory (see Figure 7).

